import sys
import random
import treelib
from treelib import Node, Tree
from scratchpad.structures import Block, ProposalMsg, VoteInfo, VoteMsg, QC
from loguru import logger

#logger.add("file_1.log", format="{time} {level} {message}", level="INFO")

logger.add("./logs/file_{time}.log", format ="{level} | {message}")

class LogEntry:
    """Fictional log entries."""
    def __init__(self, term, client, command):
        self.term = term
        self.client = client
        self.command = command

    def __str__(self):
        sl = ['LogEntry', str(self.term), str(self.client), str(self.command)]
        return ':'.join(sl)

class Validator(process):
        
    def setup(peers, maxTimeout):
        
        # Safety Class Variables
        self.private_key = None # Private Key
        self.public_keys = [] # Public keys of all replicas
        self.highest_vote_round = -1 # Max of round_value voted so far
        self.highest_qc_round = -2 # Max of highQC voted so far

        # Block Tree Variables
        self.pending_block_tree = None
        self.pending_votes = None
        self.high_qc = None
        self.high_commit_qc = None
        self.f = 1
        self.first_time = True
        # ledger Variables
        self.genesis_block = Block(
            author = self, 
            roundx = -1, 
            payload = "No Op", 
            qc = None, 
            parent = None, 
            isCommitted = True,
            idx = -1)    # block_id 
        
        self.ledger_tree = Tree()
        self.ledger_tree.create_node("genesis_block",-1, data = self.genesis_block)

        # Leader Election Variables
        self.validators = [] # The list of current validators
        self.window_size = 0 # A parameter for the leader reputation algorithm
        self.exclude_size = 0 # Between f and 2f, no. of excluded authors of last committed blocks
        self.reputation_leaders = {} # Map from round numbers to leaders elected due to the reputation scheme
        self.peers = peers
        
        # Pacemaker Variables
        self.current_round = 0
        self.last_round_tc = None

        # Mempool
        self.mempool = [] # Queue to maintain client transactions      

    def run():
        while True:
            
            --receive   
            pass
        #     pass
        # #     output("Inside main loop")
        #     while len(mempool) > 0:
        #         output("Mempool loop")
        #         if self == Leader_Election_get_leader():
        #             round_timeout = 0
        #         else:
        #             round_timeout = random.randint(int(maxTimeout/2), maxTimeout) / 1000
                
        #         validator_term(round_timeout)
    
    # def process_new_round_event():
    #     if len(mempool) > 0:
    #         if self == Leader_Election_get_leader():
    #             b = Block_Tree_generate_block(mempool[0], current_round)
    #             process_new_round_event
    #         else:
    #             pass
    #             # Wait proposal 
    #             # Do something with timeout


    def receive(msg = ("ClientRequest", txn), from_=client):
        output(f"Client Request Received for {txn}")
        mempool.append(txn)
        if first_time and self == Leader_Election_get_leader(current_round):
            first_time = False    
            process_new_round_event()
    
        
    
    def process_incoming_msgs():
        --receive

    # def receive(msg =("ProposalMsg", P), from_=Leader_Election_get_leader()):
    #     process_proposal_msg(P)

    
    ############ Safety Module ############
    def Safety_increase_highest_vote_round(c_round):
        """ Commit not to vote in rounds < highest_vote_round
        Args:
            round (int): current round number
        """
        highest_vote_round = max(c_round,highest_vote_round)

    def Safety_update_highest_qc_round(qc_round) :
        """ Update the highest qc round 

        Args:
            qc_round (int): 
        """
        highest_qc_round = max(qc_round, highest_qc_round)
    
    def Safety_consecutive(block_round, round):
        """
        To check if `block_round` is the next round of `round` or not 

        Args:
            block_round (int): [description]
            round (int): [description]
        Returns:
            bool: True if `block_round` == round + 1 else False
        """
        return round + 1 == block_round
    
    # def Safety_safe_to_extend(block_round, qc_round, tc) :
    #     # TODO : Check the type of tc
    #     """ 
    #     To check if current tc is safe to extend or not 

    #     Args:
    #         block_round (int): [description]
    #         qc_round (int): [description]
    #         tc (): [description]
    #     Returns:
    #         bool: 
    #     """
    #     # Two Conditions 
    #     # 1. block_round is next round of tc.round
    #     # 2. qc_round >= max (tc.tmo_high_qc_rounds)
    #     return Safety_consecutive(block_round, tc.round) \
    #         and qc_round >= max(tc.tmo_high_qc_rounds)
    
    def Safety_safe_to_vote(block_round, qc_round, tc) :
        """
        To check if current tc is safe to vote or not

        Args:
            block_round (int): [description]
            qc_round (int): [description]
            tc (): [description]

        Returns:
            bool: [description]
        """
        # Two Conditions 
        # 1. Must vote in monotonically increasing rounds
        # 2. Must extend a smaller round

        if block_round <= max(highest_vote_round, qc_round):
            return False

        # Extending QC from previous round || safe to extend due to tc
        return Safety_consecutive(block_round, qc_round) 
        #    or safe_to_extend(block_round, qc_round, tc)
    
    # def Safety_commit_state_id_candidate(block_round, qc):
    #     """[summary]

    #     Args:
    #         block_round ([type]): [description]
    #         qc ([type]): [description]
    #     """
    #     # Find the committed id in case a qc is formed in the vote round

    #     if Safety_consecutive(block_round, qc.vote_info.roundx):
    #         return Ledger_pending_state(qc._id)
    #     else:
    #         return None 
    
    def Safety_make_vote(b, last_tc = None):
        # Handling Base Cases 
        # Case 1 : 1st Round : 1 Proposal, 0 QC
        if b.qc is None and current_round == 0:
            qc_round = -1
            logger.critical(f"source : -> {self} Round info block round :{b.roundx} : QC round {qc_round}")
            logger.critical(f"source : -> {self} Block : {b}")
            
            if Safety_safe_to_vote(b.roundx, qc_round, None):
                Safety_update_highest_qc_round(qc_round) # Protect QC round
                Safety_increase_highest_vote_round(b.roundx)
                vote_info = VoteInfo(idx = b.idx, roundx = b.roundx, parent_id = -1, parent_round = qc_round)
                vote_msg = VoteMsg(vote_info = vote_info, high_commit_qc = high_commit_qc, sender = self)
                logger.debug(f"source : -> {self} Vote Msg Created : {str(vote_msg)}")
                return vote_msg

        else:
            qc_round = b.qc.vote_info.roundx  # qc_round of block
            if Safety_safe_to_vote(b.roundx, qc_round, None):
                Safety_update_highest_qc_round(qc_round) # Protect QC round
                Safety_increase_highest_vote_round(b.roundx)
                vote_info = VoteInfo(idx = b.idx, roundx = b.roundx, parent_id = b.qc.vote_info.idx, parent_round = qc_round )
                vote_msg = VoteMsg(vote_info = vote_info, high_commit_qc = high_commit_qc, sender = self)
                return vote_msg

        return None
    
    # def Safety_make_timeout(roundx, high_qc, last_tc = None):
    #     # if self.valid_signatures(b, last_tc) and self.safe_to_vote(b.round, qc_round, last_tc):
    #     #     self.update_highest_qc_round(qc_round)
    #     #     self.increase_highest_vote_round(b.round)
    #     pass

    # def Safety_valid_signatures(b, last_tc):
    #     # TODO : Implement this : Validate with available Public keys 
    #     return True
    
    ########### Ledger ############ 
    def Ledger_speculate(prev_block_id, block_id, block, txns):
        logger.debug(f"source : {self} -> Creating New Node in ledger for {str(block.roundx)} at {self}")
        if prev_block_id is None:
            ledger_tree.create_node(str(txns), identifier=block.idx, parent=-1, data = block)
        else:
            ledger_tree.create_node(str(txns), identifier=block.idx, parent=prev_block_id, data = block)
        
        logger.debug(f"source : {self} -> Node Created..")

        output(ledger_tree.show(idhidden=False, data_property='isCommitted'))
        
        return
    
    # def Ledger_pending_state(block_id):
    #     if ledger_tree.get_node(block_id).data.isCommitted:
    #         return None
    #     else:
    #         return 

    def Ledger_commit(block_id):
        logger.critical(f"source : {self} -> trying to commit block : {block_id}")
        logger.critical(f"source : {self} -> Ledger Tree View : ")
        output(ledger_tree.show(idhidden=False, data_property='isCommitted'))
        if not ledger_tree.get_node(block_id).data.isCommitted:
            logger.critical(f"Trying to commit block with block id :{block_id}")
            ledger_tree.get_node(block_id).data.isCommitted = True
            logger.critical(f"Node with given block id :{node}")
            #isCommitted = True
            logger.debug(f"source : {self} -> Block : {block_id} committed")

    # def Ledger_commit_block(block_id):
    #     ledger_tree.get_node(block_id).data.block
    
    # ############ Block Tree ############ 
    def Block_Tree_process_qc(qc):
        if qc is None:
            return
        logger.debug(f"source : {self} -> Parent ID : {qc.vote_info.parent_id}")
        #ledger_tree.show(idhidden=True)
        
        Ledger_commit(qc.vote_info.parent_id)
        if high_qc is None : # Base case
            high_qc = qc
            logger.debug(f"source : {self} -> High qc updated to {high_qc}")
        elif qc.vote_info.roundx > high_qc.vote_info.roundx:
            high_qc = qc
            logger.debug(f"source : {self} -> High qc updated to {high_qc}")

        if high_commit_qc is None : # Base case
            high_commit_qc = qc
            logger.debug(f"source : {self} -> High Commit qc updated to {high_commit_qc}")
        elif qc.vote_info.roundx > high_commit_qc.vote_info.roundx:
            high_commit_qc = qc
            logger.debug(f"source : {self} -> High Commit qc updated to {high_qc}")

    def Block_Tree_process_vote(vote_msg):
        Block_Tree_process_qc(vote_msg.high_commit_qc)
        
        # TODO : Implement Timeout
        if await(len(setof(p, received(('VoteMsg',_),
                                       from_=p))) >= 2*f+1):
        
            logger.debug(f"source : {self} -> Received Votes from 2*f + 1")
            reset(received)
            qc = QC(vote_info=vote_msg.vote_info, author = self)
            logger.debug(f"source : {self} -> QC Formed for {qc} broadcasting to all")
            return qc
        return None
    ############ Leader Election ############ 
    def Leader_Election_update_leaders(qc):
        pass
    
    def Leader_Election_get_leader(c_round=None):
        # current leader = current_round % len(peers)
        if c_round is None:
            c_round = current_round

        leader_id = c_round % len(peers)
        return list(peers)[leader_id]
    
    ############ Pacemaker ############  
    def Pacemaker_start_timer(new_round):
        output(f"Advancing to {new_round} from {current_round}")
        current_round = new_round

    def Pacemaker_advance_round_qc(qc):
        output(f"Current round : {current_round} with qc : {qc}")
        if qc is None:
            return False

        output(f"Current round : {current_round} with vote_info : {qc}")
        
        if qc.vote_info.roundx < current_round:
            return False

        Pacemaker_start_timer(qc.vote_info.roundx+1)
        last_round_tc = None
        #start_timer(qc.vote.info.round+1)  # TODO : Implement this
        return True
    
    def process_certificate_qc(qc):
        Block_Tree_process_qc(qc)
        Leader_Election_update_leaders(qc)
        if Pacemaker_advance_round_qc(qc):
            logger.critical(f"source : {self} -> Advance Round Completed. New Round : {current_round}")
        
    def process_proposal_msg(P):
        output("Processing process_certificate qc")
        process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)
        
        roundx = current_round
        current_leader = Leader_Election_get_leader(current_round)
        
        if P.block.roundx != roundx or P.block.author != current_leader:
            return
        
        Block_Tree_execute_and_insert(P.block)  # Adding a new speculative state to ledger

        vote_msg = Safety_make_vote(P.block)
        if vote_msg is not None:
            output(f"Sending msg to {Leader_Election_get_leader(current_round+1)}")
            send(('VoteMsg',vote_msg), to=Leader_Election_get_leader(current_round+1))
    
    def process_vote_msg(P):
        qc = Block_Tree_process_vote(P)
        if qc is not None:
            process_certificate_qc(qc)
            process_new_round_event(None)
    

    def Block_Tree_generate_block(txns, current_round):
        b = Block(author=self, roundx=current_round, payload = txns, qc=high_qc, parent = None, isCommitted = False, idx=-1)
        b = b._replace(idx = hash(b))
        return b
    
    def Block_Tree_execute_and_insert(b):
        if b.qc is None:
            qc_block_id = None
        else:
            qc_block_id = b.qc.vote_info.idx

        Ledger_speculate(qc_block_id, b.idx, b, b.payload)
        if b.payload in mempool:
            mempool.remove(b.payload)
    
    
    def process_new_round_event(last_tc = None):
        if self == Leader_Election_get_leader(current_round):
            logger.critical(f"Generating Proposal Msg for {current_round} with {mempool[0]}")
            b = Block_Tree_generate_block(mempool[0], current_round)
            #a = mempool.pop(0)
            p = ProposalMsg(block=b, last_round_tc=last_tc, high_commit_qc=high_commit_qc)
            send(('ProposalMsg', p), to=peers)
            
    def receive(msg= ('ProposalMsg',P), from_=Leader_Election_get_leader(current_round)):
        output(f"Received Proposal Msg from {Leader_Election_get_leader(current_round)}")
        process_proposal_msg(P)
    
    def receive(msg= ('VoteMsg', P)):
        output(f"Received VoteMsg...")
        process_vote_msg(P)

class Client(process):
    def setup(servers, nrequests, timeout): pass

    def run():
        commands = ["start", "abc", "def", "ghi"]
        #target = random.choice(servers)
        req = 0

        debug(f"Starting Client with servers : {servers}")
        try:
            while req < len(commands):
                req_text = commands[req]
                target = servers
                output(f"Sending {req_text} to {servers}")
                send(('ClientRequest', req_text), to=servers)
                req += 1
                # if await(some(received(('NotLeader', _req_text, leader)),
                #               has= leader is not None)):
                #     debug("Wrong server, changing to", leader)
                #     target = leader
                #     reset(received)
                # elif some(received(('Reply', _req_text, _))):
                #     output("Request", commands[req + 1], "complete.")
                #     req += 1
                # elif timeout(timeout/1000):
                #     debug("Server", target, "timed out, choosing new one randomly.")
                #     target = random.choice(servers)
        except Exception as e:
            logger.critical(f"Exception Caught : {e}")
    #send(('Done',), to=parent())

def main():
    nservers = int(sys.argv[1]) if len(sys.argv) > 1 else 3
    nclients = int(sys.argv[2]) if len(sys.argv) > 2 else 1
    nrequests = int(sys.argv[3]) if len(sys.argv) > 3 else 3
    maxtimeout = int(sys.argv[4]) if len(sys.argv) > 4 else 3000
    send_failrate = float(sys.argv[5]) if len(sys.argv) > 5 else 0.0
    config(channel="fifo")
    servers = new(Validator, num= nservers, send= send_failrate)
    setup(servers, (servers, maxtimeout))
    clients = new(Client, num= nclients)
    setup(clients, (list(servers), nrequests, maxtimeout))
    start(servers)
    start(clients)
    await(each(c in clients, has=received(('Done',), from_=c)))
    output("All clients done.")
    end(servers)