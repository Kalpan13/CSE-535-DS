import sys
from treelib import Tree
from scratchpad.structures import Block, ProposalMsg, VoteInfo, VoteMsg, QC, Txn, TimeoutInfo, TC, TimeoutMsg, pendingTOBlock
from loguru import logger
from nacl.signing import SigningKey

logger.add("./logs/file_{time}.log", format="{time} | {level} | {message}")

class Validator(process):
    def setup(peers, maxTimeout, server_public_keys, client_public_keys, private_key, client, leaderFail):

        # Safety Class Variables
        self.highest_vote_round = -1   # Max of round_value voted so far
        self.highest_qc_round = -2     # Max of highQC voted so far
        self.first_time = True

        # Block Tree Variables
        self.pending_block_tree = None
        self.pending_votes = None
        self.high_qc = None
        self.high_commit_qc = None
        self.f = 0
        self.first_time = True
        self.counter = 0
        self.client = client
        self.process_new_round_event_called = {}
        
        # ledger Variables
        self.genesis_block = Block(
            author=self,
            roundx=-1,
            payload="No Op",
            qc=None,
            parent=None,
            isCommitted=True,
            idx=-1)         # block_id
        
        self.pending_block_tree = Tree()
        self.pending_block_tree.create_node("genesis_block", -1, data=self.genesis_block)

        self.ledger_tree = Tree()
        self.ledger_tree.create_node("genesis_block", -1, data=self.genesis_block)

        # Leader Election Variables
        self.validators = []   # The list of current validators
        self.window_size = 0   # A parameter for the leader reputation algorithm
        self.exclude_size = 0   # Between f and 2f, no. of excluded authors of last committed blocks
        self.reputation_leaders = {}   # Map from round numbers to leaders elected due to the reputation scheme
        self.peers = peers

        # Pacemaker Variables
        self.current_round = 0
        self.last_round_tc = None
        self.pending_timeouts = {}
        # Mempool
        self.mempool = []   # Queue to maintain client transactions

        # Program End
        self.run_done = False
        self.timer_duration = 10
        self.leaderFail = leaderFail

    def run():
        while True:
            run_done = False
            if await(some(received(('ProposalMsg', _, _)))):
                reset(received)    
                pass
            elif await(some(received(('TimeoutMsg',_)))):
                reset(received)    
                pass
            elif timeout(10):
                run_done = True
                logger.info(f"source : {self} -> Processing new round event..")
                Pacemaker_local_timeout_round()
                timer_duration = Pacemaker_get_round_timer(current_round)
            
            timer_duration = Pacemaker_get_round_timer(current_round)

    def receive(msg=('TimeoutMsg', T), from_=replica):
        """Recevier for TimoutMsg. Calls process_timeout_msg()
        """
        logger.info(f"source : {self} -> Timeout msg received from {replica}")
        process_timeout_msg(T)

    def receive(msg = ("ClientRequest", txn_signed, txn_orig), from_=client):
        """Receiver for Client Request Handler. Calls process_new_round_event()
        """
        txn = client_public_keys[client].verify(txn_signed).decode('UTF-8')
        if str(txn_orig)==txn:
            logger.info(f"source : {self} -> Client Request Received for {txn} and Verified...!")
            mempool.append(txn_orig)
            if first_time and self == Leader_Election_get_leader(current_round):
                first_time = False
                process_new_round_event()
            
    def process_timeout_msg(M):
        """To process incoming "local timeout
        Args:
            M (TimeoutMsg): Incoming Timeout msg
        """
        process_certificate_qc(M.tmo_info.high_qc)
        process_certificate_qc(M.high_commit_qc)
        Pacemaker_advance_round_tc(M.last_round_tc)
        tc = Pacemaker_process_remote_timeout(M)
        if tc is not None:
            logger.info(f"source : {self} -> TC Formed : {tc}")
            Pacemaker_advance_round_tc(tc)
            logger.info(f"source {self} -> Processing New Round event")
            process_new_round_event(tc)
    
    ############ Safety Module ############
    def Safety_increase_highest_vote_round(c_round):
        """ Commit not to vote in rounds < highest_vote_round
        Args:
            round (int): current round number
        """
        highest_vote_round = max(c_round,highest_vote_round)

    def Safety_update_highest_qc_round(qc_round) :
        """ Update the highest qc round

        Args:
            qc_round (int): QC round
        """
        highest_qc_round = max(qc_round, highest_qc_round)

    def Safety_consecutive(block_round, round):
        """
        To check if `block_round` is the next round of `round` or not 

        Args:
            block_round (int): round of a block
            round (int): 
        Returns:
            bool: True if `block_round` == round + 1 else False
        """
        return round + 1 == block_round
    
    def get_max(tmo_high_qc_rounds):
        """list of tmo_high_qc_rounds
        
        Args:
            tmo_high_qc_rounds : tmo_high_qc_rounds

        Returns:
            int : max value of tmo_high_qc_round
        """
        tmo_high_qc_round = None
        tmo_high_qc_round = max([i for i in tmo_high_qc_rounds if i is not None])
        if tmo_high_qc_round is None:
            return 0
        else:
            return tmo_high_qc_round

    def Safety_safe_to_extend(block_round, qc_round, tc) :
        """ 
        To check if current tc is safe to extend or not 

        Args:
            block_round (int): 
            qc_round (int): 
            tc (TC): 
        Returns:
            bool: True if conditions are satisifed else False
        """
        # Two Conditions 
        # 1. block_round is next round of tc.round
        # 2. qc_round >= max (tc.tmo_high_qc_rounds)
        return Safety_consecutive(block_round, tc.roundx) and qc_round >= get_max(tc.tmo_high_qc_rounds)
            
    def Safety_safe_to_vote(block_round, qc_round, tc) :
        """
        To check if current tc is safe to vote or not

        Args:
            block_round (int): 
            qc_round (int): 
            tc (TC): 

        Returns:
            bool: True if conditions are satisifed else False
        """
        # Two Conditions 
        # 1. Must vote in monotonically increasing rounds
        # 2. Must extend a smaller round

        if block_round <= max(highest_vote_round, qc_round):
            return False

        # Extending QC from previous round || safe to extend due to tc
        return Safety_consecutive(block_round, qc_round) \
            or Safety_safe_to_extend(block_round, qc_round, tc)
    
    def Safety_safe_to_timeout(roundx, qc_round, tc):
        """To check if timeout is possible or not

        Args:
            roundx (int): 
            qc_round (int): 
            tc (TC): 

        Returns:
            bool: True if conditions are satisifed else False
        """
        if qc_round is None:  # Base case
            if tc is not None:
                return Safety_consecutive(roundx, tc.roundx)
            else:
                return True
        else:
            if qc_round < highest_qc_round or \
                roundx < max(highest_vote_round-1, qc_round):
                return False

        return Safety_consecutive(roundx, qc_round) or Safety_consecutive(roundx, tc.roundx)
    
    def Safety_make_vote(b, last_tc = None):
        """Create a Vote Msg for a proposal msg

        Args:
            b (Block): 
            last_tc (TC, optional): last round's TC. Defaults to None.

        Returns:
            VoteMsg : 
        """
        # Handling Base Cases 
        if b.qc is None:
            qc_round = current_round - 1  # Base case
            
            if Safety_safe_to_vote(b.roundx, qc_round, last_tc):
                Safety_update_highest_qc_round(qc_round) # Protect QC round
                Safety_increase_highest_vote_round(b.roundx)
                vote_info = VoteInfo(idx = b.idx, roundx = b.roundx, parent_id = -1, parent_round = qc_round)
                vote_msg = VoteMsg(vote_info = vote_info, high_commit_qc = high_commit_qc, sender = self)
                logger.info(f"source : -> {self} Vote Msg Created : {str(vote_msg)}")
                return vote_msg
        else:
            qc_round = b.qc.vote_info.roundx  # qc_round of block
            if Safety_safe_to_vote(b.roundx, qc_round, last_tc):
                Safety_update_highest_qc_round(qc_round) # Protect QC round
                Safety_increase_highest_vote_round(b.roundx)
                vote_info = VoteInfo(idx = b.idx, roundx = b.roundx, parent_id = b.qc.vote_info.idx, parent_round = qc_round)
                vote_msg = VoteMsg(vote_info = vote_info, high_commit_qc = high_commit_qc, sender = self)
                logger.info(f"source : -> {self} Vote Msg Created : {str(vote_msg)}")
                return vote_msg
        return None
    
    def Safety_make_timeout(roundx, high_qc, last_tc = None):
        """To Create Timeout

        Args:
            roundx (int): 
            high_qc (QC): 
            last_tc (TC, optional): TC of last round. Defaults to None.

        Returns:
            TimeoutInfo : 
        """
        logger.info(f"source : {self} -> Stuck here")
        if high_qc is not None:
            qc_round = high_qc.vote_info.roundx
        else:
            qc_round = None

        if Safety_safe_to_timeout(roundx, qc_round, last_tc):
            Safety_increase_highest_vote_round(roundx)
            tmo_info = TimeoutInfo(roundx=roundx,high_qc=high_qc, sender=self)
            return tmo_info
        
        return None

    ########### pending tree ############ 
    def pending_block_tree_prune(block_id):
        """To prune all the nodes except current node from parent

        Args:
            block_id : block_id of current node 
        """
        for sibling in pending_block_tree.siblings(block_id):
            pending_block_tree.remove_node(sibling.identifier)

    def pending_block_tree_add(b):
        """Create a new block under in pending block tree

        Args:
            b (Block): Block to be added in pending tree
        """
        if b.qc is None:
            pending_block_tree.create_node(str(b.payload), identifier=b.idx, parent=-1, data = b)
        else:
            pending_block_tree.create_node(str(b.payload), identifier=b.idx, parent=b.qc.vote_info.idx, data = b)
    
    ########### Ledger ############ 
    def Ledger_speculate(prev_block_id, block_id, block, txns):
        """Creates a new block in ledger under `prev_block_id`

        Args:
            prev_block_id (int): block_id of parent block
            block_id (int): block_id of current block
            block (Block): current block
            txns (Txn): payload
        """
        logger.info(f"source : {self} -> Creating New Node in ledger for {str(block.roundx)} at {self}")
        if prev_block_id is None:
            ledger_tree.create_node(str(txns), identifier=block.idx, parent=-1, data = block)
        else:
            ledger_tree.create_node(str(txns), identifier=block.idx, parent=prev_block_id, data = block)
        
        
        logger.info(f"source : {self} -> Tree View : {ledger_tree.to_json()}")
        output(ledger_tree.show(idhidden=False, data_property='payload'))
        return
    
    def Ledger_commit(block_id):
        """Commits the given block_id

        Args:
            block_id (int): `block_id` of node to be committed
        """
        logger.info(f"source : {self} -> Get Node : {ledger_tree.get_node(block_id)}")
        try:
            if not ledger_tree.get_node(block_id).data.isCommitted:
                logger.info(f"source : {self} -> trying to commit block : {block_id}")    
                logger.info(f"Node with given block id :{ledger_tree.get_node(block_id).data.isCommitted}")
                #isCommitted = True
                ledger_tree.get_node(block_id).data = ledger_tree.get_node(block_id).data._replace(isCommitted=True)
                logger.info(f"source : {self} -> Block : {block_id} committed")
                print(f"Current Replica : {self}")
                ledger_tree.show(idhidden=False, data_property='payload')
                for sibling in ledger_tree.siblings(block_id):
                    ledger_tree.remove_node(sibling.identifier)
                return True
            return False
        except Exception as e:
            return False
    
    # ############ Block Tree ############ 
    def Block_Tree_process_qc(qc):
        """To process QC formed in prev round

        Args:
            qc (QC): Quorum Certificate Generated in previous round
        """
        if qc is None:
            return
        
        committed = Ledger_commit(qc.vote_info.parent_id)
        pending_block_tree_prune(qc.vote_info.parent_id)

        if self == Leader_Election_get_leader(current_round) and committed:
            txn = ledger_tree.get_node(qc.vote_info.parent_id).data.payload
            signed_command = private_key.sign(txn.command.encode('UTF-8'))
            send(('Done', txn.command, signed_command),to=txn.sender)
            
        if high_qc is None : # Base case
            high_qc = qc
            logger.info(f"source : {self} -> High qc updated to {high_qc}")
        elif qc.vote_info.roundx > high_qc.vote_info.roundx:
            high_qc = qc
            logger.info(f"source : {self} -> High qc updated to {high_qc}")

        if not committed:
            return

        if high_commit_qc is None : # Base case
            high_commit_qc = qc
            logger.info(f"source : {self} -> High Commit qc updated to {high_commit_qc}")
        elif qc.vote_info.roundx > high_commit_qc.vote_info.roundx:
            high_commit_qc = qc
            logger.info(f"source : {self} -> High Commit qc updated to {high_qc}")

    def Block_Tree_process_vote(vote_msg):
        """Process vote msg generated in prev_round

        Args:
            vote_msg (VoteMsg): 
        """
        Block_Tree_process_qc(vote_msg.high_commit_qc)
        
        if self == Leader_Election_get_leader(current_round+1):
            logger.info(f"source : {self} -> Wating for 2*f + 1 vote msgs, leader : {Leader_Election_get_leader(current_round)}")
            if await(len(setof(p, received(('VoteMsg',_),
                                        from_=p))) >= 2*f+1):

                if self != Leader_Election_get_leader(current_round):
                    logger.info(f"source : {self} -> Received Votes from 2*f + 1")
                    reset(received)
                    qc = QC(vote_info=vote_msg.vote_info, author = self)
                    logger.info(f"source : {self} -> QC Formed : {qc}. Broadcasting to all")
                    return qc
        return None

    ############ Leader Election ############ 
    def Leader_Election_update_leaders(qc):
        pass
    
    def Leader_Election_get_leader(c_round=None):
        """Get leader of a given round

        Args:
            c_round (int): round number.

        Returns:
            Validator: 
        """

        if c_round is None:
            c_round = current_round
        leader_id = c_round % len(peers)
        return list(peers)[leader_id]
    
    ############ Pacemaker ############  
    def Pacemaker_start_timer(new_round):
        logger.info(f"source : {self} -> Advancing to {new_round} from {current_round} : run_done {run_done}")
        current_round = new_round
        run_done = False
        
    def Pacemaker_advance_round_qc(qc):
        """Advance current round to current_round + 1

        Args:
            qc (QC): 

        """
        output(f"Current round : {current_round} with qc : {qc}")
        if qc is None:
            return False

        if qc.vote_info.roundx < current_round:
            return False

        logger.info(f"source : {self} -> Advancing to {current_round + 1} from {current_round}")
        Pacemaker_start_timer(qc.vote_info.roundx+1)
        last_round_tc = None
        return True

    def Pacemaker_advance_round_tc(tc):
        """Advance round in case TC is formed

        Args:
            tc ([type]): [description]

        Returns:
            [type]: [description]
        """
        logger.info(f"Current tc : {tc}")
        if tc is None or tc.roundx < current_round:
            return False
        last_round_tc = tc
        run_done = True
        logger.info(f"source : {self} -> Pacemaker advancing round tc")
        Pacemaker_start_timer(tc.roundx+1)
        return True

    def Pacemaker_process_remote_timeout(T):
        tmo_info = T.tmo_info
        if tmo_info.roundx < current_round:
            return None
        
        if tmo_info.sender not in pending_timeouts.get(tmo_info.roundx, pendingTOBlock()).senders:
            pending_to_block = pending_timeouts.get(tmo_info.roundx,pendingTOBlock()) 
            updated_senders = pending_to_block.senders.union({tmo_info.sender})
            pending_to_block = pending_to_block._replace(senders=updated_senders)
            pending_to_block_tmo_info = pending_to_block.tmo_info
            pending_to_block_tmo_info.append(tmo_info)
            pending_to_block = pending_to_block._replace(tmo_info=pending_to_block_tmo_info)
            pending_timeouts[tmo_info.roundx] = pending_to_block

            logger.info(f"source : {self} -> Pending Timeouts {pending_timeouts}")

        if len(pending_timeouts[tmo_info.roundx].senders) >= (2*f+1):
            tmo_high_qc_rounds = [t.high_qc.vote_info.roundx if t.high_qc is not None else None for t in pending_timeouts[tmo_info.roundx].tmo_info]
            tc = TC(roundx=tmo_info.roundx, tmo_high_qc_rounds = tmo_high_qc_rounds)
            logger.info(f"sender : {self} -> TC genrated : {tc}")
            return tc

    def Pacemaker_get_round_timer(current_round):
        return 650

    def Pacemaker_local_timeout_round():
        timeout_info = Safety_make_timeout(current_round, high_qc, last_round_tc)
        logger.info(f"sender :{self} -> Timeout Info Created : {timeout_info}")
        timeout_msg = TimeoutMsg(tmo_info=timeout_info,last_round_tc=last_round_tc,high_commit_qc=high_commit_qc)
        logger.info(f"sender :{self} -> Broadcasting Timeout msg : {timeout_msg}")
        send(('TimeoutMsg', timeout_msg), to=peers)
        
    def process_certificate_qc(qc):
        logger.info(f"source : {self} -> Reached process certificate QC : {qc}")
        Block_Tree_process_qc(qc)
        Leader_Election_update_leaders(qc)
        if Pacemaker_advance_round_qc(qc):
            logger.info(f"source : {self} -> Advance Round Completed. New Round : {current_round}")
        
    def process_proposal_msg(P):
        logger.info("Processing process_certificate qc")
        process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)
        Pacemaker_advance_round_tc(P.last_round_tc)
        roundx = current_round
        current_leader = Leader_Election_get_leader(current_round)
        if P.block.roundx != roundx or P.block.author != current_leader:
            return
        Block_Tree_execute_and_insert(P.block)  # Adding a new speculative state to ledger
        pending_block_tree_add(P.block)
        vote_msg = Safety_make_vote(P.block,P.last_round_tc)
        if vote_msg is not None:
            logger.info(f"source : {self} -> Sending msg to {Leader_Election_get_leader(current_round+1)}")
            send(('VoteMsg',vote_msg), to=Leader_Election_get_leader(current_round+1))
            return
        
    def process_vote_msg(P):
        qc = Block_Tree_process_vote(P)
        if qc is not None:
            process_certificate_qc(qc)
            process_new_round_event(None)
    

    def Block_Tree_generate_block(txns, current_round):
        b = Block(author=self, roundx=current_round, payload = txns, qc=high_qc, parent = None, isCommitted = False, idx=-1)
        b = b._replace(idx = hash(b))
        return b
    
    def Block_Tree_execute_and_insert(b):
        if b.qc is None:
            qc_block_id = None
        else:
            qc_block_id = b.qc.vote_info.idx

        Ledger_speculate(qc_block_id, b.idx, b, b.payload)
        if b.payload in mempool:
            mempool.remove(b.payload)
    
    
    def process_new_round_event(last_tc = None):
        logger.info(f"******************************{current_round}******************************************")
        logger.info(f"Leader : {Leader_Election_get_leader(current_round)}")
            
        if self == Leader_Election_get_leader(current_round) and not leaderFail:
            logger.info(f"Mempool size : {len(mempool)}")
            if await(len(mempool)!=0):
                b = Block_Tree_generate_block(mempool[0], current_round)
                logger.info(f"source : {self} -> Generating Proposal Msg for {current_round} with {mempool[0].command}")
                p = ProposalMsg(block=b, last_round_tc=last_tc, high_commit_qc=high_commit_qc)
                logger.info(f"source : {self} -> Generated Proposal : {p} for {current_round} with {mempool[0].command}")
                
                send(('ProposalMsg', p,  private_key.sign(str(p).encode('UTF-8'))), to=peers)
                #if await(self!=Leader_Election_get_leader(current_round))
        
            elif timeout(5):
                send(('Done',), to=parent())
                
        return None       


    def receive(msg= ('ProposalMsg',P, signed_P), from_=replica):
        logger.info(f"source : {self} -> Received Proposal Msg from {replica} : Msg : {P}")
        run_done = True
        #logger.info(f'For* {self} {str(signed_P)}')
        if str((P)) == server_public_keys[replica].verify(signed_P).decode('UTF-8'):
           logger.info(f"source : {self} -> Proposal message verified from {replica}")
        process_proposal_msg(P)
        logger.info(f"source : {self} -> Proposal Msg sent.....")
        return 

    def receive(msg= ('VoteMsg', P), from_=replica):
        logger.info(f"source {self} -> Received VoteMsg... from {replica}")
        process_vote_msg(P)
        return 

class Client(process):
    def setup(servers, nrequests, timeout, server_public_keys, private_key): 
        self.retransmit_timeout = timeout
        self.pending_done = []

    def receive(msg= ('Done', command, signed_command), from_=replica):
        if command == server_public_keys[replica].verify(signed_command).decode('UTF-8'):
            logger.info(f"--> Received Done for {command} from {replica} and verified")
            if command in pending_done:
                pending_done.remove(command)
                logger.info(f"Removing :{command}--> new pending_done : {pending_done}")
        return 

    def run():
        commands = ["start", "abc", "def"]
        pending_done = commands.copy()
        commands.extend(["No Op","No Op"])
        
        req = 0
        ack_received = set()
        debug(f"Starting Client with servers : {servers}")
        try:
            while req < len(commands):
                command = commands[req]
                txn = Txn(sender=self, command=command)

                req_text = private_key.sign(str(txn).encode('UTF-8'))
                logger.info(f"Sending {commands[req]} to {servers}")
                send(('ClientRequest', req_text, txn), to=servers)
                req+=1
        except Exception as e:
            pass

        notDone = True
        count = 0

        while notDone:
            if await (len(pending_done)==0):
                send(('Done',), to=parent())
            
            elif timeout(15):
                logger.info("Retransmission Started")
                if len(pending_done) > 0:
                    command = pending_done[0]
                    txn = Txn(sender=self, command=command)
                    req_text = private_key.sign(str(txn).encode('UTF-8'))
                    logger.info(f"Retransmitting {command} to {servers}")
                    send(('ClientRequest', req_text, txn), to=servers)
                    
                    command = "No Op"
                    txn = Txn(sender=self, command=command)
                    req_text = private_key.sign(str(txn).encode('UTF-8'))
                    logger.info(f"Retransmitting {'re :'+command} to {servers}")
                    send(('ClientRequest', req_text, txn), to=servers)
                    txn = Txn(sender=self, command=command)
                    req_text = private_key.sign(str(txn).encode('UTF-8'))
                    logger.info(f"Retransmitting {'re :'+command} to {servers}")
                    send(('ClientRequest', req_text, txn), to=servers)
                else:
                    send(('Done',), to=parent())


def main():

    nservers = int(sys.argv[1]) if len(sys.argv) > 1 else 6
    nclients = int(sys.argv[2]) if len(sys.argv) > 2 else 2
    nrequests = int(sys.argv[3]) if len(sys.argv) > 3 else 3
    maxtimeout = int(sys.argv[4]) if len(sys.argv) > 4 else 3
    send_failrate = float(sys.argv[5]) if len(sys.argv) > 5 else 0.0
    config(channel="fifo")
    servers = new(Validator, num= nservers, send= 0.0)
    clients = new(Client, num= nclients)

    server_public_keys = {}
    server_private_keys = {}
    client_public_keys = {}
    client_private_keys = {}

    for server in servers:
        server_private_key = SigningKey.generate()
        server_public_key = server_private_key.verify_key
        server_public_keys[server] = server_public_key
        server_private_keys[server] = server_private_key

    for client in clients:
        client_private_key = SigningKey.generate()
        client_public_key = client_private_key.verify_key
        client_public_keys[client] = client_public_key
        client_private_keys[client] = client_private_key
   
    for idx, server in enumerate(servers):
        # if idx == 4:
        #     setup(server, (servers, maxtimeout, server_public_keys,client_public_keys, server_private_keys[server], clients, True))
        # else:
            setup(server, (servers, maxtimeout, server_public_keys,client_public_keys, server_private_keys[server], clients, False))

    for client in clients:    
        setup(client, (list(servers), nrequests, maxtimeout, server_public_keys, client_private_keys[client]))

    start(servers)
    start(clients)
    await(each(c in clients, has=received(('Done',), from_=c)))
    end(clients)
    end(servers)
    logger.info("All clients done.")
    