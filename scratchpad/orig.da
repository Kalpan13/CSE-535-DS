import sys
from treelib import Tree
from scratchpad.structures import Block, ProposalMsg, VoteInfo, VoteMsg, QC, Txn
from loguru import logger
from nacl.signing import SigningKey

logger.add("./logs/file_{time}.log", format="{level} | {message}")


class LogEntry:
    """Fictional log entries."""
    def __init__(self, term, client, command):
        self.term = term
        self.client = client
        self.command = command

    def __str__(self):
        sl = ['LogEntry', str(self.term), str(self.client), str(self.command)]
        return ':'.join(sl)


class Validator(process):
    def setup(peers, maxTimeout, server_public_keys, client_public_keys, private_key, client):

        # Safety Class Variables
        self.highest_vote_round = -1   # Max of round_value voted so far
        self.highest_qc_round = -2     # Max of highQC voted so far
        self.first_time = True

        # Block Tree Variables
        self.pending_block_tree = None
        self.pending_votes = None
        self.high_qc = None
        self.high_commit_qc = None
        self.f = 2
        self.first_time = True
        self.counter = 0
        self.client = client

        # ledger Variables
        self.genesis_block = Block(
            author=self,
            roundx=-1,
            payload="No Op",
            qc=None,
            parent=None,
            isCommitted=True,
            idx=-1)         # block_id
        self.pending_block_tree = Tree()
        self.pending_block_tree.create_node("genesis_block", -1, data=self.genesis_block)

        self.ledger_tree = Tree()
        self.ledger_tree.create_node("genesis_block", -1, data=self.genesis_block)

        # Leader Election Variables
        self.validators = []   # The list of current validators
        self.window_size = 0   # A parameter for the leader reputation algorithm
        self.exclude_size = 0   # Between f and 2f, no. of excluded authors of last committed blocks
        self.reputation_leaders = {}   # Map from round numbers to leaders elected due to the reputation scheme
        self.peers = peers

        # Pacemaker Variables
        self.current_round = 0
        self.last_round_tc = None

        # Mempool
        self.mempool = []   # Queue to maintain client transactions

        # Program End
        self.alive = True

    def run():
        while alive:
            #logger.info(f"source : {self} -> Current Leader {Leader_Election_get_leader(current_round)}")
            --receive

        if not alive:
            return

        #     pass
        # #     output("Inside main loop")
        #     while len(mempool) > 0:
        #         output("Mempool loop")
        #         if self == Leader_Election_get_leader():
        #             round_timeout = 0
        #         else:
        #             round_timeout = random.randint(int(maxTimeout/2), maxTimeout) / 1000
        #         validator_term(round_timeout)
    
    # def process_new_round_event():
    #     if len(mempool) > 0:
    #         if self == Leader_Election_get_leader():
    #             b = Block_Tree_generate_block(mempool[0], current_round)
    #             process_new_round_event
    #         else:
    #             pass
    #             # Wait proposal 
    #             # Do something with timeout


    def receive(msg = ("ClientRequest", txn_signed, txn_orig), from_=client):

        txn = client_public_keys[client].verify(txn_signed).decode('UTF-8')
        if str(txn_orig)==txn:
            logger.debug(f"Client Request Received for {txn} and Verified...!")
            mempool.append(txn_orig)
            if first_time and self == Leader_Election_get_leader(current_round):
                first_time = False    
                process_new_round_event()
    def process_incoming_msgs():
        --receive

    # def receive(msg =("ProposalMsg", P), from_=Leader_Election_get_leader()):
    #     process_proposal_msg(P)

    ############ Safety Module ############
    def Safety_increase_highest_vote_round(c_round):
        """ Commit not to vote in rounds < highest_vote_round
        Args:
            round (int): current round number
        """
        highest_vote_round = max(c_round,highest_vote_round)

    def Safety_update_highest_qc_round(qc_round) :
        """ Update the highest qc round

        Args:
            qc_round (int):
        """
        highest_qc_round = max(qc_round, highest_qc_round)

    def Safety_consecutive(block_round, round):
        """
        To check if `block_round` is the next round of `round` or not 

        Args:
            block_round (int): [description]
            round (int): [description]
        Returns:
            bool: True if `block_round` == round + 1 else False
        """
        return round + 1 == block_round
    
    # def Safety_safe_to_extend(block_round, qc_round, tc) :
    #     # TODO : Check the type of tc
    #     """ 
    #     To check if current tc is safe to extend or not 

    #     Args:
    #         block_round (int): [description]
    #         qc_round (int): [description]
    #         tc (): [description]
    #     Returns:
    #         bool: 
    #     """
    #     # Two Conditions 
    #     # 1. block_round is next round of tc.round
    #     # 2. qc_round >= max (tc.tmo_high_qc_rounds)
    #     return Safety_consecutive(block_round, tc.round) \
    #         and qc_round >= max(tc.tmo_high_qc_rounds)
    
    def Safety_safe_to_vote(block_round, qc_round, tc) :
        """
        To check if current tc is safe to vote or not

        Args:
            block_round (int): [description]
            qc_round (int): [description]
            tc (): [description]

        Returns:
            bool: [description]
        """
        # Two Conditions 
        # 1. Must vote in monotonically increasing rounds
        # 2. Must extend a smaller round

        if block_round <= max(highest_vote_round, qc_round):
            return False

        # Extending QC from previous round || safe to extend due to tc
        return Safety_consecutive(block_round, qc_round) 
        #    or safe_to_extend(block_round, qc_round, tc)
    
    # def Safety_commit_state_id_candidate(block_round, qc):
    #     """[summary]

    #     Args:
    #         block_round ([type]): [description]
    #         qc ([type]): [description]
    #     """
    #     # Find the committed id in case a qc is formed in the vote round

    #     if Safety_consecutive(block_round, qc.vote_info.roundx):
    #         return Ledger_pending_state(qc._id)
    #     else:
    #         return None 
    
    def Safety_make_vote(b, last_tc = None):
        # Handling Base Cases 
        # Case 1 : 1st Round : 1 Proposal, 0 QC
        if b.qc is None and current_round == 0:
            qc_round = -1
            logger.critical(f"source : -> {self} Round info block round :{b.roundx} : QC round {qc_round}")
            logger.critical(f"source : -> {self} Block : {b}")
            
            if Safety_safe_to_vote(b.roundx, qc_round, None):
                Safety_update_highest_qc_round(qc_round) # Protect QC round
                Safety_increase_highest_vote_round(b.roundx)
                vote_info = VoteInfo(idx = b.idx, roundx = b.roundx, parent_id = -1, parent_round = qc_round)
                vote_msg = VoteMsg(vote_info = vote_info, high_commit_qc = high_commit_qc, sender = self)
                logger.debug(f"source : -> {self} Vote Msg Created : {str(vote_msg)}")
                return vote_msg

        else:
            qc_round = b.qc.vote_info.roundx  # qc_round of block
            if Safety_safe_to_vote(b.roundx, qc_round, None):
                Safety_update_highest_qc_round(qc_round) # Protect QC round
                Safety_increase_highest_vote_round(b.roundx)
                vote_info = VoteInfo(idx = b.idx, roundx = b.roundx, parent_id = b.qc.vote_info.idx, parent_round = qc_round)
                vote_msg = VoteMsg(vote_info = vote_info, high_commit_qc = high_commit_qc, sender = self)
                return vote_msg

        return None
    
    # def Safety_make_timeout(roundx, high_qc, last_tc = None):
    #     # if self.valid_signatures(b, last_tc) and self.safe_to_vote(b.round, qc_round, last_tc):
    #     #     self.update_highest_qc_round(qc_round)
    #     #     self.increase_highest_vote_round(b.round)
    #     pass

    # def Safety_valid_signatures(b, last_tc):
    #     # TODO : Implement this : Validate with available Public keys 
    #     return True
    
    ########### pending tree ############ 
    def pending_block_tree_prune(block_id):
        for sibling in pending_block_tree.siblings(block_id):
            pending_block_tree.remove_node(sibling.identifier)

    def pending_block_tree_add(b):
        if b.qc is None:
            pending_block_tree.create_node(str(b.payload), identifier=b.idx, parent=-1, data = b)
        else:
            pending_block_tree.create_node(str(b.payload), identifier=b.idx, parent=b.qc.vote_info.idx, data = b)
    
    ########### Ledger ############ 
    def Ledger_speculate(prev_block_id, block_id, block, txns):
        logger.debug(f"source : {self} -> Creating New Node in ledger for {str(block.roundx)} at {self}")
        if prev_block_id is None:
            ledger_tree.create_node(str(txns), identifier=block.idx, parent=-1, data = block)
        else:
            ledger_tree.create_node(str(txns), identifier=block.idx, parent=prev_block_id, data = block)
        
        logger.debug(f"source : {self} -> Node Created..")

        #output(ledger_tree.show(idhidden=False, data_property='payload'))
        
        return
    
    # def Ledger_pending_state(block_id):
    #     if ledger_tree.get_node(block_id).data.isCommitted:
    #         return None
    #     else:
    #         return 

    def Ledger_commit(block_id):
        logger.critical(f"source : {self} -> Ledger Tree View : ")

        if not ledger_tree.get_node(block_id).data.isCommitted:
            logger.critical(f"source : {self} -> trying to commit block : {block_id}")    
            logger.critical(f"Node with given block id :{ledger_tree.get_node(block_id).data.isCommitted}")
            #isCommitted = True
            ledger_tree.get_node(block_id).data = ledger_tree.get_node(block_id).data._replace(isCommitted=True)
            logger.debug(f"source : {self} -> Block : {block_id} committed")
            print(f"Current Replica : {self}")
            logger.debug(ledger_tree.show(idhidden=False, data_property='payload'))
    
            return True
        return False

    # def Ledger_commit_block(block_id):
    #     ledger_tree.get_node(block_id).data.block
    
    # ############ Block Tree ############ 
    def Block_Tree_process_qc(qc):
        if qc is None:
            return
        logger.debug(f"source : {self} -> Parent ID : {qc.vote_info.parent_id}")
        #ledger_tree.show(idhidden=True)
        
        committed = Ledger_commit(qc.vote_info.parent_id)
        pending_block_tree_prune(qc.vote_info.parent_id)

        if self == Leader_Election_get_leader(current_round) and committed:
            txn = ledger_tree.get_node(qc.vote_info.parent_id).data.payload
            signed_command = private_key.sign(txn.command.encode('UTF-8'))
            send(('Done', txn.command, signed_command),to=txn.sender)
            
        if high_qc is None : # Base case
            high_qc = qc
            logger.debug(f"source : {self} -> High qc updated to {high_qc}")
        elif qc.vote_info.roundx > high_qc.vote_info.roundx:
            high_qc = qc
            logger.debug(f"source : {self} -> High qc updated to {high_qc}")

        if not committed:
            return

        if high_commit_qc is None : # Base case
            high_commit_qc = qc
            logger.debug(f"source : {self} -> High Commit qc updated to {high_commit_qc}")
        elif qc.vote_info.roundx > high_commit_qc.vote_info.roundx:
            high_commit_qc = qc
            logger.debug(f"source : {self} -> High Commit qc updated to {high_qc}")

    def Block_Tree_process_vote(vote_msg):
        Block_Tree_process_qc(vote_msg.high_commit_qc)
        
        # TODO : Implement Timeout
        if await(len(setof(p, received(('VoteMsg',_),
                                       from_=p))) >= 2*f+1):

            # s = None
            # s = received(('VoteMsg',_),from_=p)
            # logger.critical(f"Sender Details : {s}")
            logger.debug(f"source : {self} -> Received Votes from 2*f + 1")
            reset(received)
            qc = QC(vote_info=vote_msg.vote_info, author = self)
            logger.debug(f"source : {self} -> QC Formed for {qc} broadcasting to all")
            return qc
        return None
    ############ Leader Election ############ 
    def Leader_Election_update_leaders(qc):
        pass
    
    def Leader_Election_get_leader(c_round=None):
        # current leader = current_round % len(peers)
        if c_round is None:
            c_round = current_round

        leader_id = c_round % len(peers)
        return list(peers)[leader_id]
    
    ############ Pacemaker ############  
    def Pacemaker_start_timer(new_round):
        logger.debug(f"Advancing to {new_round} from {current_round}")
        current_round = new_round

    def Pacemaker_advance_round_qc(qc):
        #output(f"Current round : {current_round} with qc : {qc}")
        if qc is None:
            return False

        #output(f"Current round : {current_round} with vote_info : {qc}")
        
        if qc.vote_info.roundx < current_round:
            return False

        logger.critical(f"source : {self} -> Advancing to {current_round + 1} from {current_round}")
        
        Pacemaker_start_timer(qc.vote_info.roundx+1)
        last_round_tc = None
        #start_timer(qc.vote.info.round+1)  # TODO : Implement this
        return True
    
    def process_certificate_qc(qc):
        logger.debug("Reached process certificate QC")
        Block_Tree_process_qc(qc)
        Leader_Election_update_leaders(qc)
        if Pacemaker_advance_round_qc(qc):
            logger.critical(f"source : {self} -> Advance Round Completed. New Round : {current_round}")
        
    def process_proposal_msg(P):
        logger.debug("Processing process_certificate qc")
        process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)
        
        roundx = current_round
        current_leader = Leader_Election_get_leader(current_round)
        
        if P.block.roundx != roundx or P.block.author != current_leader:
            return
        
        Block_Tree_execute_and_insert(P.block)  # Adding a new speculative state to ledger
        pending_block_tree_add(P.block)
        vote_msg = Safety_make_vote(P.block)
        if vote_msg is not None:
            logger.debug(f"Sending msg to {Leader_Election_get_leader(current_round+1)}")
            send(('VoteMsg',vote_msg), to=Leader_Election_get_leader(current_round+1))
    
    def process_vote_msg(P):
        logger.debug("Reached in process_vote_msg")
        qc = Block_Tree_process_vote(P)
        logger.debug("Block_Tree_process_vote completed")
        if qc is not None:
            process_certificate_qc(qc)
            process_new_round_event(None)
    

    def Block_Tree_generate_block(txns, current_round):
        b = Block(author=self, roundx=current_round, payload = txns, qc=high_qc, parent = None, isCommitted = False, idx=-1)
        b = b._replace(idx = hash(b))
        return b
    
    def Block_Tree_execute_and_insert(b):
        if b.qc is None:
            qc_block_id = None
        else:
            qc_block_id = b.qc.vote_info.idx

        Ledger_speculate(qc_block_id, b.idx, b, b.payload)
        if b.payload in mempool:
            mempool.remove(b.payload)
    
    
    def process_new_round_event(last_tc = None):
        logger.debug("******************************",current_round,"******************************************")
        
        if self == Leader_Election_get_leader(current_round):
            if len(mempool)==0:
                logger.error("Reached till No Op")
                mempool.append(Txn(sender=None, command="No Op"))
            else:
                logger.critical(f"source : {self} -> Generating Proposal Msg for {current_round} with {mempool[0].command}")
                
            b = Block_Tree_generate_block(mempool[0], current_round)
            #a = mempool.pop(0)
            p = ProposalMsg(block=b, last_round_tc=last_tc, high_commit_qc=high_commit_qc)

            send(('ProposalMsg', p,  private_key.sign(str(p).encode('UTF-8'))), to=peers)
            
            await(self!=Leader_Election_get_leader(current_round))

    def receive(msg= ('ProposalMsg',P, signed_P), from_=replica):
        logger.debug(f"Received Proposal Msg from {replica}")
        #logger.debug(f'For* {self} {str(signed_P)}')
        if str((P)) == server_public_keys[replica].verify(signed_P).decode('UTF-8'):
           logger.debug(f"Proposal message verified from {replica}")
        process_proposal_msg(P)
    
    def receive(msg= ('VoteMsg', P)):
        logger.debug(f"Received VoteMsg...")
        process_vote_msg(P)

class Client(process):
    def setup(servers, nrequests, timeout, server_public_keys, private_key): pass
        
    def run():
        commands = ["start", "abc", "def"]
        #target = random.choice(servers)
        req = 0
        ack_received = set()
        debug(f"Starting Client with servers : {servers}")
        try:
            while req < len(commands):
                command = commands[req]
                txn = Txn(sender=self, command=command)

                req_text = private_key.sign(str(txn).encode('UTF-8'))
                logger.debug(f"Sending {commands[req]} to {servers}")
                send(('ClientRequest', req_text, txn), to=servers)
                # if await(some(received(('NotLeader', _req, leader)),
                #           has= leader is not None)):
                #     debug("Wrong server, changing to", leader)
                #     target = leader
                #     reset(received)
                req+=1
        except Exception as e:
            logger.critical(f"Exception caught : {e}")        
        notDone = True
        count = 0
        while notDone:
            if await(some(received(('Done', command, signed_command),from_=replica))):
                if command == server_public_keys[replica].verify(signed_command).decode('UTF-8'):
                    logger.critical(f"Received Done for {command} from {replica} and verified")
                    count+=1
                    reset(received)
                    if count==len(commands):
                        notDone = False
                        send(('Done',), to=parent())

def main():

    nservers = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    nclients = int(sys.argv[2]) if len(sys.argv) > 2 else 2
    nrequests = int(sys.argv[3]) if len(sys.argv) > 3 else 3
    maxtimeout = int(sys.argv[4]) if len(sys.argv) > 4 else 3000
    send_failrate = float(sys.argv[5]) if len(sys.argv) > 5 else 0.0
    config(channel="fifo")
    servers = new(Validator, num= nservers, send= 0.0)
    clients = new(Client, num= nclients)

    server_public_keys = {}
    server_private_keys = {}
    client_public_keys = {}
    client_private_keys = {}

    for server in servers:
        server_private_key = SigningKey.generate()
        server_public_key = server_private_key.verify_key
        server_public_keys[server] = server_public_key
        server_private_keys[server] = server_private_key

    for client in clients:
        client_private_key = SigningKey.generate()
        client_public_key = client_private_key.verify_key
        client_public_keys[client] = client_public_key
        client_private_keys[client] = client_private_key
   
    for server in servers:
        setup(server, (servers, maxtimeout, server_public_keys,client_public_keys, server_private_keys[server], clients))

    for client in clients:    
        setup(client, (list(servers), nrequests, maxtimeout, server_public_keys, client_private_keys[client]))

    start(servers)
    start(clients)
    await(each(c in clients, has=received(('Done',), from_=c)))
    logger.debug("All clients done.")
    end(servers)