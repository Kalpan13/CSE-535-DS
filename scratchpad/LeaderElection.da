from Ledger import Ledger
from PaceMaker import PaceMaker
import random

class LeaderElection:
    def __init__(self):
        self.validators = [] # The list of current validators
        self.window_size = 0 # A parameter for the leader reputation algorithm
        self.exclude_size = 0 # Between f and 2f, no. of excluded authors of last committed blocks
        self.reputation_leaders = {} # Map from round numbers to leaders elected due to the reputation scheme

    def elect_reputation_leaders(qc) -> ?:
        """ Finding a reputed leader for a particular round
        Args:
            qc(QC): Object of class Quoram Certificate
        """
        active_validators = {} # validators that signed the last window_size committed blocks
        last_authors = {} # ordered set of authors of last exclude_size committed blocks
        current_qc = qc
        
        i = 0
        while i < window_size or len(last_authors) < exclude_size:
            current_block = Ledger.committed_block(current_qc.vote_info.parent_id)
            block_author = current_block.author
            
            if i < window_size:
                active_validators = active_validators | current_qc.signatures.signers()
           
            if len(last_authors) < exclude_size:
                last_authors = last_authors | block_author

            current_qc = current_block.qc
            i = i + 1
        
        active_validators = active_validators - last_authors # contains at least 1 validator
        random.seed(qc.voteinfo.round)
        
        return random.choice(list(active_validators))

    def update_leaders(qc) -> None:
        """ Enter in new round and find a reputed leader for that round
        Args: 
            qc(QC): Object of class Quoram Certificate
        """
        extended_round = qc.vote_info.parent_round
        qc_round = qc.vote_info.round
        current_round = PaceMaker.current_round
        if extended_round + 1 == qc_round and qc_round + 1 == current_round:
            reputation_leaders[current_round + 1] = elect_reputation_leader(qc)

    def get_leader(current_round) -> ?:
        """ Fetch leader for current round
        Args:
            current_round(int): current round number
        """
        if reputation_leaders.has_key(current_round):
            return reputation_leaders[current_round]
    
        return validators[(current_round/2) % len(validators)] # Round-robin leader (two rounds per leader)


